# Fall 2022 Week 4: Mutuating, Aggregates, Filters

Template Week 4

--Readings for this week:

Sharon Machlis: How Do I?
https://smach.github.io/R4JournalismBook/HowDoI.html

Andrew Ba Tran: Transforming and analyzing data
https://github.com/profrobwells/CovidFall2020/blob/master/Reading/Transforming%20and%20Analyzing%20Data%20dplyr.pdf


--Pre-Lab Questions
1) We are looking at median income as a measure of household wealth. Look at Censusreporter.com and come up with three alternate measures for household wealth, describe the strengths and weaknesses of each compared to median income.

2) Use the Census Quick Facts tool  https://www.census.gov/quickfacts/fact/table/US/PST045221 and compare median income in  Baltimore City to the statewide median in Maryland and the United States. Describe your findings. Were you surprised? Why or why not? 


--Make good choices exercise

1) You share your median income findings with a friend in Baltimore. She looks at the results for her neighborhood, and asks, "Wait! My neighbors and I are making $61K more today than in 2010? Wow!" You know your friend is not making $61 k more in 2020 versus 2010. How do you defend or explain this analysis?


## R Libraries Background
R is a statistical programming language that is purpose built for data analysis.

There is a basic R program, which geeks call Base R, and it does a lot. We will be bringing in additional software programs known as libraries that do things to make R really operate better and easier.  

The two libraries we are going to need for this assignment are `readr` and `dplyr`. The library `readr` reads different types of data in. For this assignment, we're going to read in csv data or Comma Separated Values data. That's data that has a comma between each column of data. 

Then we're going to use `dplyr` to analyze it. 

To use a library, you need to import it. Put all your library steps at the top of your notebooks. 

That code looks like this:

```{r}
library(readr)
```

To load them both, you need to do this:

```{r}
library(readr)
library(dplyr)
```

But, because those two libraries -- and several others that we're going to use over the course of this class -- are so commonly used, there's a shortcut to loading many of the libraries we'll need:

```{r}
library(tidyverse)
```

## Importing data

The first thing we need to do is get some data to work with. We do that by reading it in. In our case, we're going to read a datatable from an "rds" file, which is a format for storing data with R. Later in the course, we'll more frequently work with a format called a CSV. A CSV is a stripped down version of a spreadsheet you might open in a program like Excel, in which each column is separated by a comma. RDS files are less common when getting data from other people.  But reading in CSVs is less foolproof than reading in rds files, so for now we'll work with rds. 

The rds file we're going to read in is from the [Small Business Administration's Paycheck Protection Program(https://www.sba.gov/funding-programs/loans/covid-19-relief-options/paycheck-protection-program)]. The program gave loans to businesses to keep people employed during the Covid-19 pandemic. We'll be working with a slice of the data that documents loans to Maryland businesses. 

So step 1 is to import the data. The code to import the data looks like this:

`baltcity_income <- read_csv("https://raw.githubusercontent.com/profrobwells/Baltimore/main/baltcity_income_clean.csv")`

Let's unpack that.

The first part -- **baltcity_income** -- is the name of a variable. 

A **variable** is just a name that we'll use to refer to some more complex thing. In this case, the more complex thing is the data we're importing into R that will be stored as a **dataframe**, which is one way R stores data. 

We can call this variable whatever we want. The variable name doesn't matter, technically.  We could use any word.  You could use your first name, if you like. Generally, though, we want to give variables names that are descriptive of the thing they refer to. Which is why we're calling this one **baltcity_income**. Variable names, by convention are one word all lower case (or two or more words connected by an underscore). You can end a variable with a number, but you can't start one with a number.

The `<-` bit, you'll recall from the basics, is the **variable assignment operator**. It's how we know we're assigning something to a word. Think of the arrow as saying "Take everything on the right of this arrow and stuff it into the thing on the left." So we're creating an empty vessel called **baltcity_income** and stuffing all this data into it. 

**read_csv()** is a function, one that only works when we've loaded the tidyverse.  A **function** is a little bit of computer code that takes in information and follows a series of pre-determined steps and spits it back out. 
A recipe to make pizza is a kind of function.  We might call it **make_pizza()**.

The function does one thing. It takes a preset collection of ingredients -- flour, water, oil, cheese, tomato, salt -- and passes them through each step outlined in a recipe, in order.  Things like: mix flour and water and oil, knead, let it sit, roll it out, put tomato sauce and cheese on it, bake it in an oven, then take it out.  

The output of our **make pizza()** function is a finished pie. 

We'll make use of a lot of pre-written functions from the tidyverse and other packages, and even write some of our own. Back to this line of code: 

`baltcity_income <- read_csv("https://raw.githubusercontent.com/profrobwells/Baltimore/main/baltcity_income_clean.csv")`

Inside of the **read_csv()** function, we've put the name of the file we want to load.  Things we put inside of function, to customize what the function does, are called **arguments**. 

The easiest thing to do, if you are confused about how to find your data, is to put your data in the same folder as as your notebook (you'll have to save that notebook first). If you do that, then you just need to put the name of the file in there (ppp_maryland.rds). If you put your data in a folder called "data" that sits next to your data notebook, your function would instead look like this: 

```{r eval=FALSE, message=FALSE}

baltcity_income<- read_csv("https://raw.githubusercontent.com/profrobwells/Baltimore/main/baltcity_income_clean.csv") %>% 
  as.data.frame()

```

```{r, echo=FALSE}
#need to update the pre_labs folder with the data
baltcity_income<- read_csv("https://raw.githubusercontent.com/profrobwells/Baltimore/main/baltcity_income_clean.csv") 

```

In this data set, each row represents a Census district, and each column represents a feature of that district: its location, the median income in 2010, 2016, 2020, the neighborhood identifier and geographic coordinators.

After loading the data, it's a good idea to get a sense of its shape.  What does it look like? There are several ways we can examine it. 

By looking in the R Studio environment window, we can see the number of rows (called "obs.", which is short for observations), and the number of columns(called variables).  We can double click on the dataframe name in the environment window, and explore it like a spreadsheet.  

There are several useful functions for getting a sense of the dataset right in our markdown document. 

If we run `glimpse(baltcity_income)`, it will give us a list of the columns, the data type for each column and and the first few values for each column.  

```{r}
glimpse(baltcity_income)
```

If we type `head(baltcity_income)`, it will print out the columns and the first six rows of data. 

```{r}
head(baltcity_income)
```
We can also click on the data name in the R Studio environment window to explore it interactively. 

## Group by and count

So what if we wanted to know how many loans were made in each Maryland county? 

To do that by hand, we'd have to take each of the 195,856 individual rows (or observations or records) and sort them into a pile. We'd put them in groups -- one for each county -- and then count them.

`dplyr` has a group by function in it that does just this. A massive amount of data analysis involves grouping like things together and then doing simple things like counting them, or averaging them together. So it's a good place to start.

So to do this, we'll take our dataset and we'll introduce a new operator: `%>%`. The best way to read that operator, in my opinion, is to interpret that as "and then do this." 

We're going to establish a pattern that will come up again and again throughout this book: `data %>% function`. In English: take your data set and then do this specific action to it. 

The first step of every analysis starts with the data being used. Then we apply functions to the data. 

In our case, the pattern that you'll use many, many times is: `data %>% group_by(COLUMN NAME) %>% summarize(VARIABLE NAME = AGGREGATE FUNCTION(COLUMN NAME))`

In our dataset, the column with neighborhood identifier is called "CSA2010." Neighborhoods overlap with Census tracts.

Here's the code to count the number of census tracts in each neighborhood:

```{r}
baltcity_income %>%
  group_by(Neighborhood) %>%
  summarise(
    count_tracts = n()
  )
```

So let's walk through that. 

We start with our dataset -- `baltcity_incomes` -- and then we tell it to group the data by a given field in the data. In this case, we wanted to group together all the counties, signified by the field name `Neighborhood`, which you could get from using the glimpse() function. After we group the data, we need to count them up. 

In dplyr, we use the `summarize()` function, [which can do alot more than just count things](http://dplyr.tidyverse.org/reference/summarise.html). 

Inside the parentheses in summarize, we set up the summaries we want. In this case, we just want a count of the number of loans for each county grouping. The line of code `count_tracts = n(),` says create a new field, called `count_tracts` and set it equal to `n()`. `n()` is a function that counts the number of rows or records in each group.  Why the letter n? The letter n is a common symbol used to denote a count of something. The number of things (or rows or observations or records) in a dataset? Statisticians call it n. There are n number of loans in this dataset. 

When we run that, we get a list of counties with a count next to them. But it's not in any order. 

So we'll add another "and then do this" symbol -- %>% -- and use a new function called `arrange()`. Arrange does what you think it does -- it arranges data in order. By default, it's in ascending order -- smallest to largest. But if we want to know the county with the most loans, we need to sort it in descending order. That looks like this:

```{r}
baltcity_income %>%
  group_by(Neighborhood) %>%
  summarise(
    count_tracts = n()
  ) %>% 
  arrange(desc(count_tracts))
```
The Census data contains a column detailing the neighborhood. It has associated the Census tracts to neighborhood names. This dataset may have several neighborhood values since Census tracts are a smaller unit of measurement.

Southwest Baltimore neighborhood is spread out over 8 census tracts, more than any other neighborhood. 

Here's the code to determine the count the number of census tracts in each neighborhood:

```{r}
baltcity_income %>%
   summarise(
    count_tracts = n()
  )
```


## Interviewing Your Data: Min, Max, Mean, Medians

What is the typical median income? What about the highest and lowest median incomes in the city?  For that, we can use the `min()` and `max()` functions. 


```{r}
baltcity_income %>%
  #temp code - remove later
  as.data.frame() %>% 
  select(Neighborhood, x2010, x2016, x2020, Census) %>% 
  summarise(
    count_tracts = n(),
    x2020_median = median(x2020, na.rm=TRUE),
    min_2020 = min(x2020, na.rm=TRUE),
    max_2020 = max(x2020, na.rm=TRUE)
  ) 
```
Here we see the typical median household income is `$49,875` by census tract for Baltimore City in 2020 (see result for x2020 median). The lowest median income was `$13,559` and the highest was `$199,531`. Citywide, the median household income was `$52,164` for 2016-2020.

Here's another quick way to determine the distribution of a particular column of data
```{r}
summary(baltcity_income$x2020)

```

This tells us the minimum, maximum, median, average (mean), and the first and third quartile, as well as rows with no values.

## Filters: Extracting Needles from Haystacks

Where are these rich and poor places?
Let's filter for the lowest value, 13559, and find out where it is

```{r}
baltcity_income %>%
  #temp code - remove later
  as.data.frame() %>% 
  select(Neighborhood, x2020) %>% 
  filter(x2020 ==13559) 
```

It is part of the Upton/Druid Heights neighborhood in West Baltimore

We can stack filters using the Or connector: |
It's above the enter key on a Mac keyboard
```{r}
baltcity_income %>%
  #temp code - remove later
  as.data.frame() %>% 
  select(Neighborhood, x2020) %>% 
  filter((x2020 ==13559) | (x2020==199531))

```

Read this for more details about logical operators
https://www.statmethods.net/management/operators.html

Let's filter for the wealthy neighborhoods, all above $100,000 
```{r}
baltcity_income %>%
  #temp code - remove later
  as.data.frame() %>% 
  select(Neighborhood, x2020) %>% 
  filter(x2020 > 100000) %>% 
  arrange(desc(x2020))

```

Using the summarise function, we can figure out an average value on a column. In this case, we're going to average all of the median income values by census tract.

```{r}
baltcity_income %>%
  as.data.frame() %>% 
  select(Neighborhood, x2020, Census) %>% 
    summarise(
    count_tracts = n(),
    x2020_avg = mean(x2020, na.rm=TRUE)) 
```

In the example above, we created a new summary value called x2020_avg that holds the result of the math, the average of the entire x2020 column of median incomes. We add the `na.rm=TRUE` to knock out any empty rows from the calculation.

## Other summarization methods: mean, median, min and max

Here's another trick, pulling out the minimum and maximum values
```{r}
baltcity_income %>%
  as.data.frame() %>% 
  select(Neighborhood, x2020, Census) %>% 
    summarise(
    count_tracts = n(),
    min_2020 = min(x2020, na.rm=TRUE),
    max_2020 = max(x2020, na.rm=TRUE))
```

To kick it up a notch, here's the same idea but with averages and medians for the three years in our data: 2010, 2016, 2020.

```{r}
baltcity_income %>%
  as.data.frame() %>% 
  select(Neighborhood, x2010, x2016, x2020, Census) %>% 
    summarise(
    count_tracts = n(),
    x2020_median = median(x2020, na.rm=TRUE),
    x2020_avg = mean(x2020, na.rm=TRUE),
    x2016_median = median(x2016, na.rm=TRUE),
    x2016_avg = mean(x2016, na.rm=TRUE),
    x2010_median = median(x2010, na.rm=TRUE),
    x2010_avg = mean(x2010, na.rm=TRUE)) 
```

Use the right diamond at `x2016_median` to see columns 5-7.



## Using sum

There's much more we can to summarize each group.
Let's pull in another dataset and summarize by group.

```{r}
#loading 2020 and 2010 Baltimore City population by race
baltcity_race <- read_csv("https://raw.githubusercontent.com/profrobwells/Baltimore/main/DataOutput/baltcity_race_7_21.csv")


```

Let's say we wanted to know the total population by white people in Baltimore? For that, we could use the `sum()` function to add up all of the population in the column "x2020_white". We put the column we want to total -- "amount" -- inside the sum() function `sum(amount)`. Note that we can simply add a new summarize function here, keeping our count_loans field in our output table.


This abbreviated slice of Census data contains columns detailing the population by race in Census tracts. There is the x2020_total which provides the full population, then x2020_white, x2020_black, x2020_hispanic. We omitted Asians and Pacific islanders and people identifying with more than one race for simplicity in this example.

Here we can select a race variable and summarize it.

```{r}
baltcity_race3 %>% 
  select(x2020_white, x2020_black) %>% 
  summarize(
    white_total = sum(x2020_white, na.rm = TRUE),
    black_total = sum(x2020_black, na.rm = TRUE)
  )


```


**Lab Question: **
We know the median income for Baltimore City (I just told you a few paragraphs ago).
Construct a filter for all census tracts below the citywide median household income.
Count them. 
What percentage of the city's census tracts are below the median? Put that in code too.
Draft a tweet with your findings.

**KEY**
```{r}
top <- baltcity_income %>%
  #temp code - remove later
  as.data.frame() %>% 
  select(Census, x2020) %>% 
  filter(x2020 > 52164) %>%
  count()
#89 census tracts above the citywide median income of $52164

bottom <- baltcity_income %>%
  #temp code - remove later
  as.data.frame() %>% 
  select(Census, x2020) %>% 
  filter(x2020 < 52164) %>%
  count()
#106 census tracts below the citywide median income of $52164

answer <- (bottom/200)
answer

```